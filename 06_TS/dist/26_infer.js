"use strict";
// 结构化子类型时有一个规则，如果实例 b 能够赋值给实例 a，则 a 中的全部属性需要能在 b 中找到
let k2 = {
    name: 'a',
    age: 1
};
let k0 = k2; // k0 的所有属性能在 k2 中找到, 可以赋值
/*
逆变与协变是泛型类型中的一个概念，当然不只只是 TS 独有的概念。简单来说，假设存在类型 T2 为 T1 的子类，
并且从 T1 派生出新类型 N<T1>以及从 T2 中派生出新类型 N<T2>。如果可以将 N<T2> 的实例赋值给类型为 N<T1> 的实例，则称为协变。
如果能将 N<T1> 的实例赋值给类型 N<T2> 的实例则称之为逆变。当然如果两种类型都不能赋值，则称为不变
*/
//# sourceMappingURL=26_infer.js.map