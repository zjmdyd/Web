{"ast":null,"code":"export default {\n  __name: 'vue3-018',\n  setup(__props, {\n    expose\n  }) {\n    expose();\n\n    /*\n    Proxy对象用于创建一个对象的代理，是用于监听一个对象的相关操作。代理对象可以监听我们对原对象的操作。\n    接下来我们将通过一个监听对象的属性操作来认识学习下什么是Proxy。\n    Proxy对象需要传入两个参数，分别是需要被Proxy代理的对象和一系列的捕获器\n    */\n    const obj = {\n      name: '_island',\n      foo: function () {\n        return this === objProxy;\n      }\n    };\n    const objProxy = new Proxy(obj, {\n      // get捕获器\n      get: function (target, key) {\n        console.log(`捕获到对象获取${key}属性的值操作`);\n        return target[key];\n      },\n      // set捕获器\n      set: function (target, key, val) {\n        console.log(`捕获到对象设置${key}属性的值操作,新值为${val}`);\n        target[key] = val;\n        return true;\n      }\n    });\n    console.log(objProxy);\n    console.log(objProxy.name = \"哈哈哈\");\n    console.log(objProxy.name);\n    console.log(obj.foo()); // false\n    console.log(objProxy.foo()); // true\n    /*\n    this指向的问题\n    Proxy对象可以对我们的目标对象进行访问，但没有做任何拦截时，也不能保证与目标对象的行为一致，\n    因为目标对象内部的this会自动改变为Proxy代理对象\n    */\n\n    /*\n    在ES5中使用Object.defineProperty（对象属性描述符）对对象的监听，\n    将一个对象进行遍历，并设定getter、setter方法进行监听和拦截。\n    \n    // 定义一个Object对象\n    const obj = {\n      name: \"_island\",\n      age: 18\n    };\n    \n    Object.keys(obj).forEach((key) => {\n      let val = obj[key];\n      Object.defineProperty(obj, key, {\n        get: function () {\n          console.log(key + \"调用了get方法\");\n          return val;\n        },\n        set: function (newVal) {\n          console.log(key + \"调用了set方法\");\n          val = newVal;\n        }\n      });\n    });\n    \n    // 操作obj对象\n    obj.name = \"QC2125\";\n    // name调用了set方法\n    obj.age = 30;\n    // age调用了set方法\n    console.log(obj.name); \n    // name调用了get方法\n    // QC2125\n    \n    Object.defineProperty的设计初衷并不是为了去监听拦截一个对象中的属性，且他也实现不了更加丰富的操作，\n    例如添加、删除属性等操作。所以在ES6中新增了Proxy对象，用于监听Object、Function的操作\n    */\n\n    /*\n    proxy是一个的代理对象，它可以代理我们对原目标的操作。\n    相比Object.defineProperty方法，Proxy监听的事件更加方便。\n    */\n\n    const __returned__ = {\n      obj,\n      objProxy\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"mappings":";;;;;;;IAMA;AACA;AACA;AACA;AACA;IACA,MAAMA,GAAG,GAAG;MACVC,IAAI,EAAE,SAAS;MACfC,GAAG,EAAE,YAAW;QACd,OAAO,IAAI,KAAKC,QAAQ;MAC1B;IACF,CAAC;IAED,MAAMA,QAAQ,GAAG,IAAIC,KAAK,CAACJ,GAAG,EAAE;MAC9B;MACAK,GAAG,EAAE,UAAUC,MAAM,EAAEC,GAAG,EAAE;QAC1BC,OAAO,CAACC,GAAG,CAAE,UAASF,GAAI,QAAO,CAAC;QAClC,OAAOD,MAAM,CAACC,GAAG,CAAC;MACpB,CAAC;MACD;MACAG,GAAG,EAAE,UAAUJ,MAAM,EAAEC,GAAG,EAAEI,GAAG,EAAE;QAC/BH,OAAO,CAACC,GAAG,CAAE,UAASF,GAAI,aAAYI,GAAI,EAAC,CAAC;QAC5CL,MAAM,CAACC,GAAG,CAAC,GAAGI,GAAG;QAEjB,OAAO,IAAI;MACb;IACF,CAAC,CAAC;IACFH,OAAO,CAACC,GAAG,CAACN,QAAQ,CAAC;IACrBK,OAAO,CAACC,GAAG,CAACN,QAAQ,CAACF,IAAI,GAAG,KAAK,CAAC;IAClCO,OAAO,CAACC,GAAG,CAACN,QAAQ,CAACF,IAAI,CAAC;IAC1BO,OAAO,CAACC,GAAG,CAACT,GAAG,CAACE,GAAG,EAAE,CAAC,CAAC,CAAC;IACxBM,OAAO,CAACC,GAAG,CAACN,QAAQ,CAACD,GAAG,EAAE,CAAC,CAAC,CAAC;IAC7B;AACA;AACA;AACA;AACA;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEA;AACA;AACA;AACA","names":["obj","name","foo","objProxy","Proxy","get","target","key","console","log","set","val"],"sources":["/Users/issuser/Desktop/Project/Web/05_vue3/vue_demo/src/components/vue3-018.vue"],"sourcesContent":["<template>\n  <div></div>\n</template>\n\n<script setup>\n\n/*\nProxy对象用于创建一个对象的代理，是用于监听一个对象的相关操作。代理对象可以监听我们对原对象的操作。\n接下来我们将通过一个监听对象的属性操作来认识学习下什么是Proxy。\nProxy对象需要传入两个参数，分别是需要被Proxy代理的对象和一系列的捕获器\n*/\nconst obj = {\n  name: '_island',\n  foo: function() {\n    return this === objProxy\n  }\n}\n\nconst objProxy = new Proxy(obj, {\n  // get捕获器\n  get: function (target, key) {\n    console.log(`捕获到对象获取${key}属性的值操作`);\n    return target[key];\n  },\n  // set捕获器\n  set: function (target, key, val) {\n    console.log(`捕获到对象设置${key}属性的值操作,新值为${val}`);\n    target[key] = val;\n\n    return true\n  }\n});\nconsole.log(objProxy);\nconsole.log(objProxy.name = \"哈哈哈\");\nconsole.log(objProxy.name);\nconsole.log(obj.foo()); // false\nconsole.log(objProxy.foo()); // true\n/*\nthis指向的问题\nProxy对象可以对我们的目标对象进行访问，但没有做任何拦截时，也不能保证与目标对象的行为一致，\n因为目标对象内部的this会自动改变为Proxy代理对象\n*/  \n\n/*\n在ES5中使用Object.defineProperty（对象属性描述符）对对象的监听，\n将一个对象进行遍历，并设定getter、setter方法进行监听和拦截。\n\n// 定义一个Object对象\nconst obj = {\n  name: \"_island\",\n  age: 18\n};\n\nObject.keys(obj).forEach((key) => {\n  let val = obj[key];\n  Object.defineProperty(obj, key, {\n    get: function () {\n      console.log(key + \"调用了get方法\");\n      return val;\n    },\n    set: function (newVal) {\n      console.log(key + \"调用了set方法\");\n      val = newVal;\n    }\n  });\n});\n\n// 操作obj对象\nobj.name = \"QC2125\";\n// name调用了set方法\nobj.age = 30;\n// age调用了set方法\nconsole.log(obj.name); \n// name调用了get方法\n// QC2125\n\nObject.defineProperty的设计初衷并不是为了去监听拦截一个对象中的属性，且他也实现不了更加丰富的操作，\n例如添加、删除属性等操作。所以在ES6中新增了Proxy对象，用于监听Object、Function的操作\n*/\n\n/*\nproxy是一个的代理对象，它可以代理我们对原目标的操作。\n相比Object.defineProperty方法，Proxy监听的事件更加方便。\n*/\n\n</script>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}